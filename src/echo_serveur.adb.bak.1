with Ada.Text_IO;           use Ada.Text_IO;
with Ada.IO_Exceptions;     use Ada.IO_Exceptions;
with GNAT.Sockets;          use GNAT.Sockets;
with Ada.Streams;           use Ada.Streams;
with Ada.Strings.Unbounded; use Ada.Strings.Unbounded;
procedure Echo_Serveur is
    ------------------------DECLARATION DE L'ENSEMBLE DES VARIABLES GLOBALES, TYPES ET SOUS-TYPES ----------------------------------------------------------------

    -- Les sous-types

    Tasks_To_Create : constant := 2; -- simultaneous socket connections.
    Nb_Max_Message  : constant := 100;
    subtype Index is Integer range 1 .. Nb_Max_Message;
    type File_Message is
       array (1 .. Nb_Max_Message) of Unbounded_String;  -- La file de message
    subtype Counter is Integer range 0 .. Tasks_To_Create;

    -- Les variables globales

    -------------------------------------------DEFINITION DE L'OBJET PROTEGE Info-------------------------------------------------------------------------------------------------
    -- On implémente notre Objet protégé sous forme d'une file circulaire.

    protected type Info is
        entry Push_Message (message : in Unbounded_String);          -- Ecrire un message dans la file
        entry Pop_Message (message_retire : out Unbounded_String);   -- Lire le message dans la file et effacer l'entrée
    private                                                          -- Les attrituts de l'information
        List_Message       : File_Message;    -- La liste des message
        Tete : Natural := 0;                 -- La tete de la file
        Queue : Natural := Nb_Max_Message;    -- La queue de la file
        Nb_Message_In_File : Natural := 0;   -- Nombre de message dans la file
    end Info;

    protected body Info is
        entry Push_Message (message : in Unbounded_String)
           when Nb_Message_In_File < Nb_Max_Message
        is -- On ajoute un message en fin de file
        begin
            List_Message (Tete) := message;
            Tete                := (Tete + 1) mod Nb_Message_In_File;
            Nb_Message_In_File  := Nb_Message_In_File + 1;
        end Push_Message;

        entry Pop_Message (message_retire : out Unbounded_String)
           when Nb_Message_In_File > 0
        is  -- On ne peux enlever le message que s'il y a u moins 1 element dans la file
        begin
            message_retire     := List_Message (Queue);
            Queue              := (Queue + 1) mod Nb_Max_Message;
            Nb_Message_In_File := Nb_Message_In_File - 1;
        end Pop_Message;
    end Info;

    Info_A                  : Info;             -- Information pour gerer les messages du client A
    Info_B                  : Info;             -- Information pour gerer les messages du client B

    -------------------------------  FIN DE LA DEFINITION DE l'OBJET PROTEGE   -----------------------------------------------------------------------------------

--On delcare les file de message de A et de B une fois le type protégé defini

------------------------------   DEFINITION DU TYPE DE TACHE Manage_Client   --------------------------------------------------------------------------------------------


-- Configurez le récepteur de socket, initialisez la pile de tâches, 
-- puis bouclez en bloquant sur Accept_Socket, en utilisant Pop_Stack 
-- pour la prochaine tâche libre de la pile, en attendant si nécessaire.


-------------------------------------------------------------------------------

-- SocketServer : Socket du Serveur; Connexion_1, Connexion : le nouveau socket retourné apres accept_Socket qui sert à relier le serveur au client;   Channel le flux de lecture

task type Manage_Client is
    entry Start;
end Manage_Client;

task body Manage_Client is
begin
    loop
        select
            accept Start do
                null;
            end Start;
            loop
                null;
            end loop;
        or
            terminate; 
        end select;
    end loop;
end Manage_Client;



begin
    Put_Line ("Hello world!");
end Echo_Serveur;
